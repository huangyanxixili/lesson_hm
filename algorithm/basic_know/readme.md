# 算法 + 小黄书 = 大厂实习

- 怎么学习算法
   - leetcode 热题100  200+题目

- 算法的核心效率
   - 时间复杂度O(n)
   - 空间复杂度

- 不要急于刷题，先打好算法基础
   - 时间复杂度
    O(1) O(n) O(n^2) O(logn) O(nlogn) O(n*m) O(2^n) O(n^3) O(n!)
   - 空间复杂度

   - 时间复杂度是怎么计算的？
       - 计算的方法？
       - 代码的执行次数 T(n)  Time 次数
       - 抓住主要矛盾， O(n) 就是执行的趋势极限...
            所以系数不重要，可以省略，主要是次方
            随着输入规模的增大，算法对应的执行次数的变化趋势
       -由执行次数T(n) 推导出时间复杂度O(n)
           - 由边界理论，输入模式无限大，时间复杂度表达的是执行次数增长**趋势**
                所以系数可以省略，抓最大次项

   - 算法不是解法，而是用恰当或更优的时间复杂度或空间复杂度
        排序：
            冒泡排序 O(n^2)
            快排  O(nlogn)

- 空间复杂度
    算法在执行过程中，占用的**额外内存空间大小**

- 数据结构
   - 线性
       - 数组 最简单最好用的
           - 内置方法很多，开箱即用
               - 建议优先考虑数组，节点 + 指针 比较复杂， []\
               - 除非 不连续 
           - 有丰富的API，栈 ，队列的 push pop ....

       - 栈 队列 链表
   - 非线性 
       - 树 
       - 图

- 算法中如何定义一个数组
    (new Array(7)).fill(1); 初始化所有元素为 1


- 访问和遍历
    arr[idx] O(1)  链表 O(n)
   - 遍历：for forEach map 